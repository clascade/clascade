<?php

namespace Clascade\Util;
use Clascade\Exception;
use Clascade\Util\Crypto\FallbackAES;

class Crypto
{
	//== AES-256-CBC encryption + HMAC-SHA512 ==//
	
	/**
	 * Encrypt a string using a symmetric key.
	 *
	 * The output will consist of:
	 *
	 * 1. A null-terminated header (version number and key index).
	 * 2. A randomly-generated IV.
	 * 3. The ciphertext.
	 * 4. An HMAC-SHA512 of all the previous output.
	 *
	 * The ciphertext is generated by padding the plaintext using
	 * PKCS7 and encrypting the result using AES-256 in CBC mode
	 * with the aforementioned IV.
	 *
	 * Both the AES encryption key and the HMAC key are derived from
	 * the provided master key using HKDF.
	 *
	 * The master key may be provided either as a string consisting
	 * of the raw bytes of the key, or as an array of possible
	 * master keys from which one master key will be randomly
	 * selected. The array index of the selection (whether a numeric
	 * or string index) will be outputted in the header information,
	 * in plain text. So, you should be careful to ensure that the
	 * array index itself doesn't leak any sensitive information!
	 *
	 * The header information at the beginning of the output will
	 * consist of a version indicator and the index of the selected
	 * master key. If the master key was provided as a single
	 * string, the key index will be treated as "0". Any backlashes
	 * in the key are escaped by another backslash, and any null
	 * bytes are replaced with '\0'. This guarantees that the first
	 * null byte in the output marks the end of the header.
	 *
	 * The caller may provide a $keys argument in order to retrieve
	 * the set of keys that this function generates from the master
	 * key. If the caller provides the argument as an existing array
	 * with more than 2 elements, this function will generate extra
	 * keys to fill the remaining elements.
	 *
	 * Note: The derived keys will be populated into $keys at
	 * sequential numeric indexes starting at 0, not necessarily the
	 * indexes of the existing values.
	 */
	
	public static function encrypt ($master_key, $plaintext, &$keys=null)
	{
		if (is_string($master_key))
		{
			// A single master key was provided. Assume a
			// key ID of 0.
			
			$key_id = 0;
		}
		elseif (is_array($master_key) && !empty ($master_key))
		{
			if (count($master_key) === 1)
			{
				// An array was provided with only one element.
				// We don't need to randomly select a key ID;
				// just take it from the only element.
				
				$key_id = Arr::firstKey($master_key);
			}
			else
			{
				// An array of master keys was provided. Select
				// a random key ID from the array.
				
				$key_id = Arr::randKey($master_key);
			}
			
			$master_key = $master_key[$key_id];
		}
		
		if (!is_string($master_key))
		{
			throw new Exception\InvalidArgumentException('The master key must be a string or an array of strings.');
		}
		
		// Determine the number of keys to derive from the
		// master key.
		
		if (is_array($keys) && count($keys) > 2)
		{
			$num_keys = count($keys);
		}
		else
		{
			$num_keys = 2;
		}
		
		// Derive keys from master key.
		
		$keys = static::hkdf('sha512', $master_key, $num_keys);
		
		// Hash the encryption key to make it the appropriate size.
		
		$enc_key = hash('sha256', $keys[0], true);
		
		// Generate an initialization vector. This ensures that
		// repeat encryptions of the same input will produce
		// different ciphertexts.
		
		$iv = Rand::getBytes(16);
		
		if (function_exists('openssl_encrypt'))
		{
			// OpenSSL pads the plaintext with PKCS7 automatically.
			
			$ciphertext = openssl_encrypt($plaintext, 'AES-256-CBC', $enc_key, \OPENSSL_RAW_DATA, $iv);
		}
		else
		{
			// Mcrypt and FallbackAES don't do PKCS7 padding on
			// their own, so we'll do it here. This will allow us
			// to restore the data to its original size after
			// decryption. Otherwise, AES would pad it with null
			// bytes, which we couldn't unambiguously remove,
			// because the data itself might end with null bytes.
			
			$pad_len = 16 - (strlen($plaintext) % 16);
			$plaintext .= str_repeat(chr($pad_len), $pad_len);
			
			if (function_exists('mcrypt_encrypt'))
			{
				// RIJNDAEL-128 was the original name of AES-256. The
				// 128 refers to the block size, not the key size.
				
				$ciphertext = mcrypt_encrypt(\MCRYPT_RIJNDAEL_128, $enc_key, $plaintext, 'cbc', $iv);
			}
			else
			{
				// Fall back to a native PHP implementation of AES.
				
				$ciphertext = FallbackAES::encryptCBC($enc_key, $iv, $plaintext);
			}
		}
		
		// Escape the key ID so it doesn't contain null bytes.
		
		$key_id = strtr($key_id, ['\\' => '\\\\', "\x00" => '\\0']);
		
		// Prepend the version number, escaped key ID, header-
		// terminating null byte, and initialization vector.
		
		$ciphertext = "\x01{$key_id}\x00{$iv}{$ciphertext}";
		
		// Generate an HMAC, which can be used to detect any
		// tampering of the data. It also gives us a reliable
		// way to verify the master key at decryption time.
		
		$hmac = hash_hmac('sha512', $ciphertext, $keys[1], true);
		
		// Append the HMAC and return.
		
		return "{$ciphertext}{$hmac}";
	}
	
	public static function decrypt ($master_key, $ciphertext, &$keys=null)
	{
		if ($ciphertext == '')
		{
			return false;
		}
		
		// Check the version number.
		
		$version = ord(substr($ciphertext, 0, 1));
		
		if ($version != 1)
		{
			return false;
		}
		
		if (!is_array($keys) || count($keys) < 2)
		{
			if (is_array($master_key) && !empty ($master_key))
			{
				$key_id = static::getKeyID($ciphertext);
				
				if ($key_id === false || !array_key_exists($key_id, $master_key))
				{
					// Bad format or the master key array doesn't
					// include the ciphertext's key ID.
					
					return false;
				}
				
				$master_key = $master_key[$key_id];
			}
			
			if (!is_string($master_key))
			{
				throw new Exception\InvalidArgumentException('The master key must be a string or an array of strings.');
			}
			
			$keys = static::hkdf('sha512', $master_key, 2);
		}
		
		// Extract the HMAC.
		
		$hmac = substr($ciphertext, -64);
		$ciphertext = substr($ciphertext, 0, -64);
		
		// Validate against the HMAC.
		
		$current_hmac = hash_hmac('sha512', $ciphertext, $keys[1], true);
		
		if (!Str::equals($hmac, $current_hmac))
		{
			// The HMAC didn't match. Either this is the wrong
			// master key, or the data was tampered with.
			
			return false;
		}
		
		// Unpack the IV and ciphertext.
		
		$pos = strpos($ciphertext, "\0", 1);
		
		if ($pos === false)
		{
			// Bad format.
			
			return false;
		}
		
		$iv = substr($ciphertext, $pos + 1, 16);
		$ciphertext = substr($ciphertext, $pos + 17);
		
		// Decrypt the ciphertext.
		
		$enc_key = hash('sha256', $keys[0], true);
		
		if (function_exists('openssl_decrypt'))
		{
			$plaintext = openssl_decrypt($ciphertext, 'AES-256-CBC', $enc_key, \OPENSSL_RAW_DATA, $iv);
		}
		else
		{
			if (function_exists('mcrypt_decrypt'))
			{
				$plaintext = mcrypt_decrypt(\MCRYPT_RIJNDAEL_128, $enc_key, $ciphertext, 'cbc', $iv);
			}
			else
			{
				$plaintext = FallbackAES::decryptCBC($enc_key, $iv, $ciphertext);
			}
			
			// Remove PKCS7 padding to restore the original length.
			
			$pad_len = ord(substr($plaintext, -1));
			$plaintext = substr($plaintext, 0, -$pad_len);
		}
		
		return $plaintext;
	}
	
	public static function getKeyID ($ciphertext)
	{
		if ($ciphertext == '')
		{
			return false;
		}
		
		$version = ord(substr($ciphertext, 0, 1));
		
		if ($version != 1)
		{
			// Unrecognized encryption scheme or format.
			
			return false;
		}
		
		// Find the end of the key ID.
		
		$pos = strpos($ciphertext, "\x00", 1);
		
		if ($pos === false)
		{
			// Unrecognized encryption scheme or format.
			
			return false;
		}
		
		// Extract the key ID.
		
		$key_id = substr($ciphertext, 1, $pos - 1);
		
		// Unescape and return the key ID.
		
		$key_id = strtr($key_id, ['\\0' => "\x00", '\\\\' => '\\']);
		return $key_id;
	}
	
	/**
	 * Derive keys from a single master key, using RFC-5869.
	 *
	 * This function can derive up to 255 keys from one master key.
	 * The key derivation is deterministic, which means that it will
	 * always produce the same sequence of derived keys when invoked
	 * with the same master key.
	 *
	 * This function omits RFC-5869's "extract" step, so it is not
	 * suitable for low-entropy inputs like user passwords. You
	 * should ensure that the master key is uniform and secure.
	 */
	
	public static function hkdf ($hash_algo, $master_key, $num_keys)
	{
		if ($num_keys > 255)
		{
			throw new Exception\DomainException("\$num_keys must be 255 or lower. {$num_keys} given.");
		}
		
		$keys = [];
		$last_key = '';
		
		for ($i = 0; $i < $num_keys; ++$i)
		{
			$last_key = hash_hmac($hash_algo, $last_key.chr($i + 1), $master_key, true);
			$keys[] = $last_key;
		}
		
		return $keys;
	}
	
	/**
	 * Randomly mask a value, such as to defend a CSRF token against
	 * a BREACH-like attack.
	 *
	 * This does NOT hide it from the end user, only from a
	 * BREACH-like side channel.
	 */
	
	public static function mask ($token)
	{
		$mask = Rand::getBytes(strlen($token));
		return ($token ^ $mask).$mask;
	}
	
	/**
	 * Unmask a value masked by Crypto::mask().
	 */
	
	public static function unmask ($token)
	{
		$len = floor(strlen($token) / 2);
		return substr($token, 0, $len) ^ substr($token, $len, $len);
	}
}
